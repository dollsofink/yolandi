import{N as y,G as C,B as v,P as O,D as b,S as T,a as w}from"./renderer-vue.es-DiMs_Wzb.js";import{A as H,_ as $,k as L,l as W,m as Y,n as q,o as z,p as X,C as J,q as Q,r as Z,E as tt,_ as et,b as st,f as nt,c as at,d as it,e as ot,i as rt,I as ut,s as ct,j as lt,t as ht,u as dt,v as pt,w as ft,x as vt,y as yt,T as gt,z as mt,F as It,H as Ct,J as Ot,K as bt,L as Tt,M as wt,h as Et,O as Nt,Q as kt,R as _t,g as St,U as Dt,V as xt,W as Pt,X as Mt,Y as At,Z as jt,$ as Rt,a0 as Ut,a1 as Bt,a2 as Ft,a3 as Vt,a4 as Kt,a5 as Gt,a6 as Ht}from"./renderer-vue.es-DiMs_Wzb.js";import"./runtime-dom.esm-bundler-_dOoQjef.js";function x(a){return class extends y{constructor(){var e,t;super(),this.type=a.type,this.inputs={},this.outputs={},this.calculate=a.calculate?(s,n)=>a.calculate.call(this,s,n):void 0,this._title=(e=a.title)!==null&&e!==void 0?e:a.type,this.executeFactory("input",a.inputs),this.executeFactory("output",a.outputs),(t=a.onCreate)===null||t===void 0||t.call(this)}onPlaced(){var e;(e=a.onPlaced)===null||e===void 0||e.call(this)}onDestroy(){var e;(e=a.onDestroy)===null||e===void 0||e.call(this)}executeFactory(e,t){Object.keys(t||{}).forEach(s=>{const n=t[s]();e==="input"?this.addInput(s,n):this.addOutput(s,n)})}}}class E extends y{}function P(a){return class extends E{constructor(){var e,t,s,n;super(),this.type=a.type,this.inputs={},this.outputs={},this.preventUpdate=!1,this.staticInputKeys=Object.keys((e=a.inputs)!==null&&e!==void 0?e:{}),this.staticOutputKeys=Object.keys((t=a.outputs)!==null&&t!==void 0?t:{}),this._title=(s=a.title)!==null&&s!==void 0?s:a.type,this.executeFactory("input",a.inputs),this.executeFactory("output",a.outputs),a.calculate&&(this.calculate=(i,r)=>{var o;return(o=a.calculate)===null||o===void 0?void 0:o.call(this,i,r)}),(n=a.onCreate)===null||n===void 0||n.call(this)}onPlaced(){var e;this.events.update.subscribe(this,t=>{t&&(t.type==="input"&&this.staticInputKeys.includes(t.name)||t.type==="output"&&this.staticOutputKeys.includes(t.name))&&this.onUpdate()}),this.onUpdate(),(e=a.onPlaced)===null||e===void 0||e.call(this)}onDestroy(){var e;(e=a.onDestroy)===null||e===void 0||e.call(this)}load(e){this.preventUpdate=!0,this.hooks.beforeLoad.execute(e),this.id=e.id,this.title=e.title;for(const t of this.staticInputKeys)this.inputs[t].load(e.inputs[t]),this.inputs[t].nodeId=this.id;for(const t of this.staticOutputKeys)this.outputs[t].load(e.outputs[t]),this.outputs[t].nodeId=this.id;this.preventUpdate=!1,this.onUpdate(),this.preventUpdate=!0;for(const t of Object.keys(e.inputs))this.staticInputKeys.includes(t)||(this.inputs[t].load(e.inputs[t]),this.inputs[t].nodeId=this.id);for(const t of Object.keys(e.outputs))this.staticOutputKeys.includes(t)||(this.outputs[t].load(e.outputs[t]),this.outputs[t].nodeId=this.id);this.preventUpdate=!1,this.events.loaded.emit(this)}onUpdate(){var e,t,s,n;if(this.preventUpdate)return;this.graph&&this.graph.activeTransactions++;const i=this.getStaticValues(this.staticInputKeys,this.inputs),r=this.getStaticValues(this.staticOutputKeys,this.outputs),o=a.onUpdate.call(this,i,r);this.updateInterfaces("input",(e=o.inputs)!==null&&e!==void 0?e:{},(t=o.forceUpdateInputs)!==null&&t!==void 0?t:[]),this.updateInterfaces("output",(s=o.outputs)!==null&&s!==void 0?s:{},(n=o.forceUpdateOutputs)!==null&&n!==void 0?n:[]),this.graph&&this.graph.activeTransactions--}getStaticValues(e,t){const s={};for(const n of e)s[n]=t[n].value;return s}updateInterfaces(e,t,s){const n=e==="input"?this.staticInputKeys:this.staticOutputKeys,i=e==="input"?this.inputs:this.outputs;for(const r of Object.keys(i))n.includes(r)||t[r]&&!s.includes(r)||(e==="input"?this.removeInput(r):this.removeOutput(r));for(const r of Object.keys(t)){if(i[r])continue;const o=t[r]();e==="input"?this.addInput(r,o):this.addOutput(r,o)}}executeFactory(e,t){Object.keys(t||{}).forEach(s=>{const n=t[s]();e==="input"?this.addInput(s,n):this.addOutput(s,n)})}}}function M(a,e){const t=new Map;e.graphs.forEach(s=>{s.nodes.forEach(n=>t.set(n.id,n))}),a.forEach((s,n)=>{const i=t.get(n);i&&s.forEach((r,o)=>{const p=i.outputs[o];p&&(p.value=r)})})}class g extends Error{constructor(){super("Cycle detected")}}function N(a){return typeof a=="string"}function m(a,e){const t=new Map,s=new Map,n=new Map;let i,r;if(a instanceof C)i=a.nodes,r=a.connections;else{if(!e)throw new Error("Invalid argument value: expected array of connections");i=a,r=e}i.forEach(c=>{Object.values(c.inputs).forEach(u=>t.set(u.id,c.id)),Object.values(c.outputs).forEach(u=>t.set(u.id,c.id))}),i.forEach(c=>{const u=r.filter(d=>d.from&&t.get(d.from.id)===c.id),l=new Set(u.map(d=>t.get(d.to.id)).filter(N));s.set(c.id,l),n.set(c,u)});const o=i.slice();r.forEach(c=>{const u=o.findIndex(l=>t.get(c.to.id)===l.id);u>=0&&o.splice(u,1)});const p=[];for(;o.length>0;){const c=o.pop();p.push(c);const u=s.get(c.id);for(;u.size>0;){const l=u.values().next().value;if(u.delete(l),Array.from(s.values()).every(d=>!d.has(l))){const d=i.find(f=>f.id===l);o.push(d)}}}if(Array.from(s.values()).some(c=>c.size>0))throw new g;return{calculationOrder:p,connectionsFromNode:n,interfaceIdToNodeId:t}}function k(a,e){try{return m(a,e),!1}catch(t){if(t instanceof g)return!0;throw t}}var h;(function(a){a.Running="Running",a.Idle="Idle",a.Paused="Paused",a.Stopped="Stopped"})(h||(h={}));class _{get status(){return this.isRunning?h.Running:this.internalStatus}constructor(e){this.editor=e,this.events={beforeRun:new O(this),afterRun:new v(this),statusChange:new v(this),beforeNodeCalculation:new v(this),afterNodeCalculation:new v(this)},this.hooks={gatherCalculationData:new T(this),transferData:new b},this.recalculateOrder=!0,this.internalStatus=h.Stopped,this.isRunning=!1,this.editor.nodeEvents.update.subscribe(this,(t,s)=>{s.graph&&!s.graph.loading&&s.graph.activeTransactions===0&&this.internalOnChange(s,t??void 0)}),this.editor.graphEvents.addNode.subscribe(this,(t,s)=>{this.recalculateOrder=!0,!s.loading&&s.activeTransactions===0&&this.internalOnChange()}),this.editor.graphEvents.removeNode.subscribe(this,(t,s)=>{this.recalculateOrder=!0,!s.loading&&s.activeTransactions===0&&this.internalOnChange()}),this.editor.graphEvents.addConnection.subscribe(this,(t,s)=>{this.recalculateOrder=!0,!s.loading&&s.activeTransactions===0&&this.internalOnChange()}),this.editor.graphEvents.removeConnection.subscribe(this,(t,s)=>{this.recalculateOrder=!0,!s.loading&&s.activeTransactions===0&&this.internalOnChange()}),this.editor.graphHooks.checkConnection.subscribe(this,t=>this.checkConnection(t.from,t.to))}start(){this.internalStatus===h.Stopped&&(this.internalStatus=h.Idle,this.events.statusChange.emit(this.status))}pause(){this.internalStatus===h.Idle&&(this.internalStatus=h.Paused,this.events.statusChange.emit(this.status))}resume(){this.internalStatus===h.Paused&&(this.internalStatus=h.Idle,this.events.statusChange.emit(this.status))}stop(){(this.internalStatus===h.Idle||this.internalStatus===h.Paused)&&(this.internalStatus=h.Stopped,this.events.statusChange.emit(this.status))}async runOnce(e,...t){if(this.events.beforeRun.emit(e).prevented)return null;try{this.isRunning=!0,this.events.statusChange.emit(this.status),this.recalculateOrder&&this.calculateOrder();const s=await this.execute(e,...t);return this.events.afterRun.emit(s),s}finally{this.isRunning=!1,this.events.statusChange.emit(this.status)}}checkConnection(e,t){if(e.templateId){const i=this.findInterfaceByTemplateId(this.editor.graph.nodes,e.templateId);if(!i)return{connectionAllowed:!0,connectionsInDanger:[]};e=i}if(t.templateId){const i=this.findInterfaceByTemplateId(this.editor.graph.nodes,t.templateId);if(!i)return{connectionAllowed:!0,connectionsInDanger:[]};t=i}const s=new w(e,t);let n=this.editor.graph.connections.slice();return t.allowMultipleConnections||(n=n.filter(i=>i.to!==t)),n.push(s),k(this.editor.graph.nodes,n)?{connectionAllowed:!1,connectionsInDanger:[]}:{connectionAllowed:!0,connectionsInDanger:t.allowMultipleConnections?[]:this.editor.graph.connections.filter(i=>i.to===t)}}calculateOrder(){this.recalculateOrder=!0}async calculateWithoutData(...e){const t=this.hooks.gatherCalculationData.execute(void 0);return await this.runOnce(t,...e)}validateNodeCalculationOutput(e,t){if(typeof t!="object")throw new Error(`Invalid calculation return value from node ${e.id} (type ${e.type})`);Object.keys(e.outputs).forEach(s=>{if(!(s in t))throw new Error(`Calculation return value from node ${e.id} (type ${e.type}) is missing key "${s}"`)})}internalOnChange(e,t){this.internalStatus===h.Idle&&this.onChange(this.recalculateOrder,e,t)}findInterfaceByTemplateId(e,t){for(const s of e)for(const n of[...Object.values(s.inputs),...Object.values(s.outputs)])if(n.templateId===t)return n;return null}}const A=a=>{a.allowMultipleConnections=!0};class j extends _{constructor(e){super(e),this.order=new Map}start(){super.start(),this.recalculateOrder=!0,this.calculateWithoutData()}async runGraph(e,t,s){this.order.has(e.id)||this.order.set(e.id,m(e));const{calculationOrder:n,connectionsFromNode:i}=this.order.get(e.id),r=new Map;for(const o of n){const p={};Object.entries(o.inputs).forEach(([u,l])=>{p[u]=this.getInterfaceValue(t,l.id)}),this.events.beforeNodeCalculation.emit({inputValues:p,node:o});let c;if(o.calculate)c=await o.calculate(p,{globalValues:s,engine:this});else{c={};for(const[u,l]of Object.entries(o.outputs))c[u]=this.getInterfaceValue(t,l.id)}this.validateNodeCalculationOutput(o,c),this.events.afterNodeCalculation.emit({outputValues:c,node:o}),r.set(o.id,new Map(Object.entries(c))),i.has(o)&&i.get(o).forEach(u=>{var l;const d=(l=Object.entries(o.outputs).find(([,I])=>I.id===u.from.id))===null||l===void 0?void 0:l[0];if(!d)throw new Error(`Could not find key for interface ${u.from.id}
This is likely a Baklava internal issue. Please report it on GitHub.`);const f=this.hooks.transferData.execute(c[d],u);u.to.allowMultipleConnections?t.has(u.to.id)?t.get(u.to.id).push(f):t.set(u.to.id,[f]):t.set(u.to.id,f)})}return r}async execute(e){this.recalculateOrder&&(this.order.clear(),this.recalculateOrder=!1);const t=this.getInputValues(this.editor.graph);return await this.runGraph(this.editor.graph,t,e)}getInputValues(e){const t=new Map;for(const s of e.nodes)Object.values(s.inputs).forEach(n=>{n.connectionCount===0&&t.set(n.id,n.value)}),s.calculate||Object.values(s.outputs).forEach(n=>{t.set(n.id,n.value)});return t}onChange(e){this.recalculateOrder=e||this.recalculateOrder,this.calculateWithoutData()}getInterfaceValue(e,t){if(!e.has(t))throw new Error(`Could not find value for interface ${t}
This is likely a Baklava internal issue. Please report it on GitHub.`);return e.get(t)}}class R{constructor(e){this.name=e,this.conversions=[]}addConversion(e,t=s=>s){return this.conversions.push({targetType:e.name,transformationFunction:t}),this}}function U(a,e){a.type=e.name}function B(a,e){a.type=e.name}function F(a){return a.type}class V{constructor(e,t){this.types=new Map,this.editor=e,this.editor.graphEvents.checkConnection.subscribe(this,({from:s,to:n},i)=>{const r=s.type,o=n.type;if(!(!r||!o)&&!this.canConvert(r,o))return i()}),t?.engine&&t.engine.hooks.transferData.subscribe(this,(s,n)=>{const i=n.from.type,r=n.to.type;return!i||!r?s:this.convert(i,r,s)}),t?.viewPlugin&&t.viewPlugin.hooks.renderInterface.subscribe(this,({intf:s,el:n})=>(s.type&&n.setAttribute("data-interface-type",s.type),{intf:s,el:n}))}addTypes(...e){return e.forEach(t=>{this.types.set(t.name,t)}),this}getConversion(e,t){var s,n;return(n=(s=this.types.get(e))===null||s===void 0?void 0:s.conversions.find(i=>i.targetType===t))!==null&&n!==void 0?n:null}canConvert(e,t){return e===t||this.types.has(e)&&this.types.get(e).conversions.some(s=>s.targetType===t)}convert(e,t,s){if(e===t)return s;{const n=this.getConversion(e,t);if(n)return n.transformationFunction(s);throw Error(`Can not convert from "${e}" to "${t}"`)}}}export{H as AbstractNode,$ as BaklavaEditor,V as BaklavaInterfaceTypes,_ as BaseEngine,L as ButtonInterface,W as ButtonInterfaceComponent,Y as CheckboxInterface,q as CheckboxInterfaceComponent,z as Commands,X as Components,J as Connection,g as CycleError,Q as DEFAULT_TOOLBAR_COMMANDS,Z as DEFAULT_TOOLBAR_SUBGRAPH_COMMANDS,j as DependencyEngine,w as DummyConnection,E as DynamicNode,tt as Editor,et as EditorComponent,h as EngineStatus,st as GRAPH_INPUT_NODE_TYPE,nt as GRAPH_NODE_TYPE_PREFIX,at as GRAPH_OUTPUT_NODE_TYPE,C as Graph,it as GraphInputNode,ot as GraphOutputNode,rt as GraphTemplate,ut as IntegerInterface,ct as IntegerInterfaceComponent,y as Node,lt as NodeInterface,R as NodeInterfaceType,ht as NumberInterface,dt as NumberInterfaceComponent,pt as SelectInterface,ft as SelectInterfaceComponent,vt as SliderInterface,yt as SliderInterfaceComponent,gt as TOOLBAR_COMMANDS,mt as TOOLBAR_SUBGRAPH_COMMANDS,It as TemporaryConnectionState,Ct as TextInputInterface,Ot as TextInputInterfaceComponent,bt as TextInterface,Tt as TextareaInputInterface,wt as TextareaInputInterfaceComponent,A as allowMultipleConnections,M as applyResult,k as containsCycle,Et as createGraphNodeType,P as defineDynamicNode,x as defineNode,Nt as displayInSidebar,kt as getDomElementOfNode,_t as getDomElements,St as getGraphNodeTypeString,Dt as getNodePosition,xt as getPortCoordinates,F as getType,Pt as isInputElement,Mt as providePlugin,At as provideTemporaryConnection,jt as setNodePosition,U as setType,B as setTypeForMultipleConnections,m as sortTopologically,Rt as useBaklava,Ut as useCommandHandler,Bt as useDragMove,Ft as useGraph,Vt as useNodeCategories,Kt as useTemporaryConnection,Gt as useTransform,Ht as useViewModel};
